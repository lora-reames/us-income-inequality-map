<!DOCTYPE html>
<meta charset="utf-8">
<style>
    svg {
        font: 10px sans-serif;
    }

    .counties {
        fill: none;
        stroke: #c2c2c2;
        stroke-width: .5px;
        stroke-linejoin: miter;
        stroke-linecap: miter;
    }

    .state {
        fill: none;
    }

    .state-borders {
        fill: none;
        stroke: #fff;
        stroke-linejoin: round;
        stroke-linecap: round;
    }

    .place {
        stroke: #fff;
        stroke-width: .25px;
    }

    .place-label {
        fill: #000;
        font-size: .4em;
        font-weight: bold;
        stroke: #fff;
        stroke-width: .2px;
    }
</style>

<body>
    <script src="//d3js.org/d3.v3.min.js"></script>
    <script src="//d3js.org/topojson.v1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js"></script>


    </script>
    <script>
        var width = 960,
            height = 500,
            active = d3.select(null);

        var projection = d3.geo.albersUsa()
            .scale(1000)
            .translate([width / 2, height / 2]);

        var color = d3.scale.threshold()
            .domain([.402, .422, .439, .461])
            .range(['#f0f9e8', '#bae4bc', '#7bccc4', '#43a2ca', '#0868ac']);

        var path = d3.geo.path()
            .projection(projection)
            .pointRadius(.5);

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .on("click", stopped, true);

        var zoom = d3.behavior.zoom()
            .translate([0, 0])
            .scale(1)
            .scaleExtent([1, 8])
            .on("zoom", zoomed);

        var giniById = d3.map();

        queue()
            .defer(d3.json, "us.json")
            .defer(d3.csv, "gini.csv", function(d) {
                giniById.set(d.id, +d.gini);
            })
            .await(ready);
        svg
            .call(zoom) // delete this line to disable free zooming
            .call(zoom.event);

        var g = svg.append("g");

        function ready(error, us) {
            if (error) throw error;
            g.append("g")
                .selectAll("path")
                .data(topojson.feature(us, us.objects.counties).features)
                .enter().append("path")
                .attr("d", path)
                .style("fill", function(d) {
                    return color(giniById.get(d.id));
                });

            // svg.append("path")
            //     .datum(topojson.mesh(us, us.objects.counties, function(a, b) {
            //         return a.id / 1000 ^ b.id / 1000;
            //     }))
            //     .attr("class", "state-borders")
            //     .attr("d", path);
            svg.selectAll("path")
                .data(topojson.feature(us, us.objects.states).features)
                .enter().append("path")
                .attr("d", path)
                .attr("class", "state")
                .on("click", clicked);

            svg.append("path")
                .datum(topojson.mesh(us, us.objects.states, function(a, b) {
                    return a !== b;
                }))
                .attr("class", "state-borders")
                .attr("d", path);
            // svg.append("path")
            //     .datum(topojson.feature(us, us.objects.places))
            //     .attr("d", path)
            //     .attr("class", "place");
            //
            // svg.selectAll(".place-label")
            //     .data(topojson.feature(us, us.objects.places).features)
            //     .enter().append("text")
            //     .attr("class", "place-label")
            //     .attr("transform", function(d) {
            //         return "translate(" + d.geometry.coordinates + ")";
            //     })
            //     .attr("x", function(d) {
            //         return d.geometry.coordinates[0] > -1 ? 2 : -2;
            //     })
            //     .attr("dy", ".35em")
            //     .style("text-anchor", function(d) {
            //         return d.geometry.coordinates[0] > -1 ? "start" : "end";
            //     })
            //     .text(function(d) {
            //         return d.properties.name;
            //     });

            // };
        }

        function clicked(d) {
            if (active.node() === this) return reset();
            active.classed("active", false);
            active = d3.select(this).classed("active", true);

            var bounds = path.bounds(d),
                dx = bounds[1][0] - bounds[0][0],
                dy = bounds[1][1] - bounds[0][1],
                x = (bounds[0][0] + bounds[1][0]) / 2,
                y = (bounds[0][1] + bounds[1][1]) / 2,
                scale = Math.max(1, Math.min(8, 0.9 / Math.max(dx / width, dy / height))),
                translate = [width / 2 - scale * x, height / 2 - scale * y];

            svg.transition()
                .duration(750)
                .call(zoom.translate(translate).scale(scale).event);
        }

        function reset() {
            active.classed("active", false);
            active = d3.select(null);

            svg.transition()
                .duration(750)
                .call(zoom.translate([0, 0]).scale(1).event);
        }

        function zoomed() {
            g.style("stroke-width", 1.5 / d3.event.scale + "px");
            g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
        }

        // If the drag behavior prevents the default click,
        // also stop propagation so we donâ€™t click-to-zoom.
        function stopped() {
            if (d3.event.defaultPrevented) d3.event.stopPropagation();
        }
    </script>
